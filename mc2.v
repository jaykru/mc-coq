Require Import Setoid.
Require Import Lia.
Require Import Coq.Program.Equality.

Axiom double_neg : forall P, P <-> ~~P.
Lemma fold_not : forall (P: Prop), (P -> False) <-> ~P. intuition auto. Defined.
Axiom forall_exists_duality1 : forall {T} (P: T -> Prop), ~ (exists x, P x) <-> (forall x, ~ P x).
Axiom forall_exists_duality2 : forall {T} (P: T -> Prop), ~ (forall x, P x) <-> (exists x, ~ P x).
Axiom DeMorgan1 : forall (P Q : Prop), ~(P /\ Q) <-> (~P \/ ~Q).
Axiom DeMorgan2 : forall (P Q : Prop), ~(P \/ Q) <-> (~P /\ ~Q).

Ltac classical := 
  repeat match goal with
  | [ H : context[_ -> False] |- _ ] => rewrite (fold_not) in H (* sometimes intuition leaves us with negations like this. *)
  | [ H : context[~(~ _)]|- _ ] => rewrite <-double_neg in H
  | [ H : _ |- _ ] => rewrite DeMorgan1 in H
  | [ H : _ |- _ ] => rewrite DeMorgan2 in H
  | [ H: _ |- _] => erewrite forall_exists_duality1 in H
  | [ H: _ |- _] => erewrite forall_exists_duality2 in H
  | [ H : _ |- context[_ -> False] ] => rewrite (fold_not) (* sometimes intuition leaves us with negations like this. *)
  | [ H : _ |- context[~(~ _)] ] => rewrite <-double_neg
  | [ H : _ |- _ ] => rewrite DeMorgan1
  | [ H : _ |- _ ] => rewrite DeMorgan2
  | [ H: _ |- _] => erewrite forall_exists_duality1
  | [ H: _ |- _] => erewrite forall_exists_duality2
  end; try solve [intuition auto].  

Section LTLdef. 
  Context {T: Type}.
  Inductive LTL : Type :=
  injp_ltl : (T -> Prop) -> LTL
  | false_ltl : LTL
  | true_ltl : LTL
  | imp_ltl : LTL -> LTL -> LTL
  | until_ltl : LTL -> LTL -> LTL
  | next_ltl : LTL -> LTL.
  Definition TemInt : Type := nat -> T.
  Notation "φ U- ψ" := (until_ltl φ ψ) (at level 10).
  Definition from (k: nat): TemInt -> TemInt :=
      fun ζ n =>
        ζ (n+k).
  Notation "ζ ^^ k" := (from k ζ) (at level 10).

  Reserved Notation "ζ ⊨ φ" (at level 50, no associativity).
  Fixpoint models (ζ : TemInt) (φ : LTL) {struct φ}: Prop :=
      match φ with
      | injp_ltl p =>
        p (ζ 0)
      | imp_ltl ψ π =>
        (~(ζ ⊨ ψ) \/ (ζ ⊨ π))
      | next_ltl ψ =>
        (from 1 ζ) ⊨ ψ
      | until_ltl ψ π =>
        (exists (i:nat),
          ζ ^^ i ⊨ π
          /\ (forall j, j < i -> ζ ^^ j ⊨ ψ))
      | false_ltl =>
        False
      | true_ltl =>
        True
      end
  where "ζ ⊨ φ" := (models ζ φ).

  Fixpoint models_upto (k:nat) (ζ : TemInt) (φ : LTL): Prop :=
      match k with
      | 0 => (* base case: modeling something for 0 cycles is vaccuously 
                false. this is the only way to make until and next work out. *)
             False
      | _ => match φ with
              | injp_ltl p =>
                p (ζ 0) (* to model an immediate property at for the next S k' cycles,
                           it suffices to satisfy it right now. *)
              | imp_ltl ψ π =>
                (models_upto k ζ ψ) -> (models_upto k ζ π)
              | next_ltl ψ =>
                (* next ψ says that ψ will be true in the next cycle.
                   for this to be true for up to k cycles,
                   we need that ψ is maintained for up to k-1 cycles by the suffix of ζ *)
                models_upto (k-1) (ζ ^^ 1) ψ
              | until_ltl ψ π =>
                exists (i:nat),
                  (i <= k)
                  /\ models_upto (k-i) (ζ ^^ i) π (* note that this *doesn't* mean
                                                     that π need be true for k-i cycles. *)
                  /\ (forall j, j < i -> ζ ^^ j ⊨ ψ)
              | false_ltl =>
                False
              | true_ltl =>
                True
        end
      end.

  Definition not_ltl (φ : LTL) : LTL := imp_ltl φ false_ltl.
  Definition ev_ltl (φ : LTL): LTL := true_ltl U- φ.
  Definition always_ltl (φ : LTL): LTL := not_ltl (ev_ltl (not_ltl φ)).
  Definition and_ltl (ϕ ψ : LTL) : LTL := not_ltl (imp_ltl ϕ (not_ltl ψ)).

  Theorem and_good : forall ζ ϕ ψ, ζ ⊨ ϕ /\ ζ ⊨ ψ <-> ζ ⊨ (and_ltl ϕ ψ).
  Proof.
    intros.
    split.
    { (* fwd *)
      intro.
      unfold  and_ltl,not_ltl.
      cbn.
      left.
      intro.
      repeat destruct H0; destruct H; auto.
    }
    {
      intro.
      split.
      {
        inversion H;
        cbn in H0;
        intuition auto;
        classical.
      }
      {
        inversion H; cbn in *; intuition auto; classical.
      }
    }
  Defined.

  Lemma ltl_not_good : forall ζ φ, ~ ζ ⊨ φ <-> ζ ⊨ (not_ltl φ).  
    Proof.
      (* Very lightly modified from a proof generated by GPT-3/copilot. *)  
      intros.
      split.
      { 
        intro H.
        unfold not_ltl.
        lazy.
        left.
        intro.
        repeat destruct H0; destruct H; auto.
      }
      {
        intro.
        inversion H; cbn in *; intuition auto; classical.
      }
    Defined.

  Theorem always_iff_loop_inv : forall (φ : LTL) (ζ : TemInt), 
    ζ ⊨ (always_ltl φ) 
    <-> (exists (i : nat), 
          (forall k, k >= i -> ζ ^^ k ⊨ φ -> ζ ^^ (k+1) ⊨ φ) /\ (forall (j : nat), j <= i -> ζ ^^ j ⊨ φ)).
  Proof.
    intros.
    split.
    { 
      intros H.
      exists 0.
      split; intros.
      {
        simpl in H.
        classical.
        destruct H; try solve [intuition auto].
        specialize (H (k+1)).
        classical.
        repeat destruct H; solve [intuition auto].
      } 
      {
        inversion H0.
        simpl in H.
        classical.
        destruct H; try solve [intuition auto].
        specialize (H 0).
        classical.
        repeat destruct H; try solve [intuition auto].
      }
    } 
    {
     intros H.  
     left.
     simpl.
     destruct H as [i [Hpres Hinit]].
     simpl.
     repeat (progress classical || intro).
     left.
     split; [|solve[intuition auto]].
     Require Import Coq.Arith.Compare_dec.
     pose proof (lt_eq_lt_dec x i) as Hcompxi.
     repeat match goal with
            | [ H : context[{_} + {_}] |- _] => destruct H as [H | H]
            end; try solve [eapply Hinit;lia].
     {
      assert (Hstronger : forall n, ζ ^^ (i+n) ⊨ φ).
      {
        induction n.
        { 
          unshelve erewrite (_ : i + 0 = i). lia.
          eapply Hinit.
          auto.
        }
        { 
          unshelve erewrite (_ : i + S n = (i + n) + 1). lia.
          eapply Hpres.
          lia.
          auto.
        }
      }
      remember (x - i) as diff.
      unshelve erewrite (_ : x = i + diff); try solve[lia].
      auto.
     }
    }
Defined.
End LTLdef.

Record Mealy : Type := mkMealy {
                           Σ : Type
                         ; Q : Type
                         ; δ : Q -> Σ -> Q * Σ
                         ; Q₀ : Q
                         }.

Fixpoint MealyTrace' (M : Mealy) (I : nat -> Σ M) (n : nat) {struct n}: (Q M) * (Σ M) :=
    match n with
    | 0 => (δ M) (Q₀ M) (I 0)
    | S n' => let (Q', _) := MealyTrace' M I n' in
             (δ M) Q' (I n)
    end.

Definition MealyTrace (M : Mealy) (I : nat -> Σ M) : @TemInt (Q M * Σ M) :=
    fun n => MealyTrace' M I n.

Definition reachability_diameter (M : Mealy) : Type :=
  { D : nat &
  forall (s : nat -> Q M) (n : nat),
    s 0 = Q₀ M 
    /\ (forall t, t <= n -> exists input, s t = fst ((δ M) (s (t-1)) input))
    -> (D <= n) 
       /\ (exists s', s' 0 = Q₀ M 
           /\ s' D = s n 
           /\ forall t, t <= D -> 
                        exists input, s' t = fst ((δ M) (s' (t-1)) input)) }.

Definition IsFinite (M: Mealy) : Prop := 
  exists (s: nat -> Q M) (D : nat), forall (q : Q M), exists (n : nat), n <= D /\ s n = q.
  
Theorem reachability_diameter_suffices_bmc (M : Mealy) (P : LTL) : 
  forall (_D : reachability_diameter M) (D : nat) (I : nat -> Σ M), 
    (exists p, P = always_ltl p) ->
    D = projT1 _D ->
    models_upto D (MealyTrace M I) P ->
    models (MealyTrace M I) P.
  Proof.
    intros.
    match goal with
    | [ H : exists p, P = always_ltl p |- _ ] => destruct H as [p H]; rewrite H in *; clear H P
    end.
    simpl.
    left.
    classical.
    intro.
    classical.
    left.
    intuition.
    (* proof proceeds by case analysis on the comparison of x and D. *)
    pose proof (lt_eq_lt_dec D x) as HcompDx.
    repeat match goal with
            | [ H : context[{_} + {_}] |- _] => destruct H as [H | H]
    end.
    {
      admit. (* D < x, hard case, need induction on x. *)
    }
    {
      (* we have `models_upto D p` and we need to show that `models (from D ζ) p` *)  
      (* D = x, case should be easy *)
      rewrite <-HcompDx in *.
      assert (HStronger: forall T (ζ: TemInt) φ, (forall k, models_upto k ζ (always_ltl φ)) -> forall t, @models T (from t ζ) φ).
      {
        intros.
        specialize (H t).
        simpl in H.        
        induction t; [solve[intuition auto]|].
        {
          induction D.
          {
            simpl in H1.
            inversion H1.
          }
          {
            simpl in IHD. eapply IHD.
            { admit. }
          }  
          simpl in H1.
          simpl in H1.
          destruct t.
        }
        {
          specialize (H (S t)).
          simpl in H.
        }
      }      
      dependent induction D.
      { simpl in H1.
        inversion H1. }
      { }
      
      induction D.
      { intros.
        simpl in H1. 
        inversion H1. }
      {
        intros.

        eapply IHD.  
       }

      unfold models_upto,always_ltl in H1.
      simpl in H1.

    }
    repeat match goal destruct HcompDx.
    { }
    { }
    
    induction x.
    {
      unfold reachability_diameter in _D.
      destruct _D as [D' H_D_reachability_diameter].
      simpl in H0.
      rewrite <-H0 in *. clear H0. clear D'.
      induction D; intuition auto.
      {
        match goal with
        | [ H : models_upto _ _ _ |- _ ] => inversion H
        end.
      }
      {
        eapply IHD.
        intros.
        split.
        {
          unshelve epose proof (_ : S D <= n).
          { 
            eapply H_D_reachability_diameter.
            eapply H.
          }
          lia.
         }
         {
          
         }
      }
      unfold models_upto in H1.
      simpl in H1.
      simpl in *.
    