Require Import Setoid.
Require Import Lia.

Axiom double_neg : forall P, P <-> ~~P.
Lemma fold_not : forall (P: Prop), (P -> False) <-> ~P. intuition auto. Defined.
Axiom forall_exists_duality1 : forall {T} (P: T -> Prop), ~ (exists x, P x) <-> (forall x, ~ P x).
Axiom forall_exists_duality2 : forall {T} (P: T -> Prop), ~ (forall x, P x) <-> (exists x, ~ P x).
Axiom DeMorgan1 : forall (P Q : Prop), ~(P /\ Q) <-> (~P \/ ~Q).
Axiom DeMorgan2 : forall (P Q : Prop), ~(P \/ Q) <-> (~P /\ ~Q).

Ltac classical := 
  repeat match goal with
  | [ H : context[_ -> False] |- _ ] => rewrite (fold_not) in H (* sometimes intuition leaves us with negations like this. *)
  | [ H : context[~(~ _)]|- _ ] => rewrite <-double_neg in H
  | [ H : _ |- _ ] => rewrite DeMorgan1 in H
  | [ H : _ |- _ ] => rewrite DeMorgan2 in H
  | [ H: _ |- _] => erewrite forall_exists_duality1 in H
  | [ H: _ |- _] => erewrite forall_exists_duality2 in H
  | [ H : _ |- context[_ -> False] ] => rewrite (fold_not) (* sometimes intuition leaves us with negations like this. *)
  | [ H : _ |- context[~(~ _)] ] => rewrite <-double_neg
  | [ H : _ |- _ ] => rewrite DeMorgan1
  | [ H : _ |- _ ] => rewrite DeMorgan2
  | [ H: _ |- _] => erewrite forall_exists_duality1
  | [ H: _ |- _] => erewrite forall_exists_duality2
  end; try solve [intuition auto].  

Section LTLdef. 
  Context {T: Type}.
  Inductive LTL : Type :=
  injp_ltl : (T -> Prop) -> LTL
  | false_ltl : LTL
  | true_ltl : LTL
  | imp_ltl : LTL -> LTL -> LTL
  | until_ltl : LTL -> LTL -> LTL
  | next_ltl : LTL -> LTL.
  Definition TemInt : Type := nat -> T.
  Notation "φ U- ψ" := (until_ltl φ ψ) (at level 10).
  Definition from (k: nat): TemInt -> TemInt :=
      fun ζ n =>
        ζ (n+k).
  Notation "ζ ^^ k" := (from k ζ) (at level 10).

  Reserved Notation "ζ ⊨ φ" (at level 50, no associativity).
  Fixpoint models (φ : LTL) (ζ : TemInt) {struct φ}: Prop :=
      match φ with
      | injp_ltl p =>
        p (ζ 0)
      | imp_ltl ψ π =>
        (~(ζ ⊨ ψ) \/ (ζ ⊨ π))
      | next_ltl ψ =>
        (from 1 ζ) ⊨ ψ
      | until_ltl ψ π =>
        (exists (i:nat),
          ζ ^^ i ⊨ π
          /\ (forall j, j < i -> ζ ^^ j ⊨ ψ))
      | false_ltl =>
        False
      | true_ltl =>
        True
      end
  where "ζ ⊨ φ" := (models φ ζ).

  Definition not_ltl (φ : LTL) : LTL := imp_ltl φ false_ltl.
  Definition ev_ltl (φ : LTL): LTL := true_ltl U- φ.
  Definition always_ltl (φ : LTL): LTL := not_ltl (ev_ltl (not_ltl φ)).
  Definition and_ltl (ϕ ψ : LTL) : LTL := not_ltl (imp_ltl ϕ (not_ltl ψ)).


  Theorem and_good : forall ζ ϕ ψ, ζ ⊨ ϕ /\ ζ ⊨ ψ <-> ζ ⊨ (and_ltl ϕ ψ).
  Proof.
    intros.
    split.
    { (* fwd *)
      intro.
      unfold  and_ltl,not_ltl.
      cbn.
      left.
      intro.
      repeat destruct H0; destruct H; auto.
    }
    {
      intro.
      split.
      {
        inversion H;
        cbn in H0;
        intuition auto;
        classical.
      }
      {
        inversion H; cbn in *; intuition auto; classical.
      }
    }
  Defined.

  Lemma ltl_not_good : forall ζ φ, ~ ζ ⊨ φ <-> ζ ⊨ (not_ltl φ).  
    Proof.
      (* Very lightly modified from a proof generated by GPT-3/copilot. *)  
      intros.
      split.
      { 
        intro H.
        unfold not_ltl.
        lazy.
        left.
        intro.
        repeat destruct H0; destruct H; auto.
      }
      {
        intro.
        inversion H; cbn in *; intuition auto; classical.
      }
    Defined.

  Theorem always_iff_loop_inv : forall (φ : LTL) (ζ : TemInt), 
    ζ ⊨ (always_ltl φ) 
    <-> (exists (i : nat), 
          (forall k, k >= i -> ζ ^^ k ⊨ φ -> ζ ^^ (k+1) ⊨ φ) /\ (forall (j : nat), j <= i -> ζ ^^ j ⊨ φ)).
  Proof.
    intros.
    split.
    { 
      intros H.
      exists 0.
      split; intros.
      {
        simpl in H.
        classical.
        destruct H; try solve [intuition auto].
        specialize (H (k+1)).
        classical.
        repeat destruct H; solve [intuition auto].
      } 
      {
        inversion H0.
        simpl in H.
        classical.
        destruct H; try solve [intuition auto].
        specialize (H 0).
        classical.
        repeat destruct H; try solve [intuition auto].
      }
    } 
    {
     intros H.  
     left.
     simpl.
     destruct H as [i [Hpres Hinit]].
     simpl.
     repeat (progress classical || intro).
     left.
     split; [|solve[intuition auto]].
     Require Import Coq.Arith.Compare_dec.
     pose proof (lt_eq_lt_dec x i) as Hcompxi.
     repeat match goal with
            | [ H : context[{_} + {_}] |- _] => destruct H as [H | H]
            end; try solve [eapply Hinit;lia].
     {
      assert (Hstronger : forall n, ζ ^^ (i+n) ⊨ φ).
      {
        induction n.
        { 
          unshelve erewrite (_ : i + 0 = i). lia.
          eapply Hinit.
          auto.
        }
        { 
          unshelve erewrite (_ : i + S n = (i + n) + 1). lia.
          eapply Hpres.
          lia.
          auto.
        }
      }
      remember (x - i) as diff.
      unshelve erewrite (_ : x = i + diff); try solve[lia].
      auto.
     }
    }
Defined.
End LTLdef.

Record Mealy : Type := mkMealy {
                           Σ : Type
                         ; Q : Type
                         ; δ : Q -> Σ -> Q * Σ
                         ; Q₀ : Q
                         }.

Fixpoint MealyTrace' (M : Mealy) (I : nat -> Σ M) (n : nat) {struct n}: (Q M) * (Σ M) :=
    match n with
    | 0 => (δ M) (Q₀ M) (I 0)
    | S n' => let (Q', _) := MealyTrace' M I n' in
             (δ M) Q' (I n)
    end.

Definition MealyTrace (M : Mealy) (I : nat -> Σ M) : @TemInt (Q M * Σ M) :=
    fun n => MealyTrace' M I n.